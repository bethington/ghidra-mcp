# PowerShell script to extract Ghidra defined data via list_data_items_by_xrefs and format for todo list
param(
    [string]$DllName = "D2Common.dll",
    [string]$OutputFile = "",
    [string]$GhidraUrl = "http://127.0.0.1:8089",
    [int]$Limit = 5000,
    [switch]$DATOnly,
    [switch]$Preview,
    [switch]$Help
)

# Auto-generate output file name if not provided
if ([string]::IsNullOrEmpty($OutputFile)) {
    $baseName = [System.IO.Path]::GetFileNameWithoutExtension($DllName)
    $OutputFile = "${baseName}DataTodo.txt"
}

function Show-Help {
    Write-Host @"
GHIDRA DATA EXTRACTOR - list_data_items_by_xrefs VERSION
=========================================================

USAGE:
    .\extract_ghidra_data_REST.ps1 [OPTIONS]

OPTIONS:
    -DllName <name>       DLL name for header/documentation (default: D2Common.dll)
    -OutputFile <file>    Output file path (default: auto-generated from DLL name)
    -GhidraUrl <url>      Ghidra REST API base URL (default: http://127.0.0.1:8089)
    -Limit <number>       Maximum data items to fetch (default: 5000)
    -DATOnly              Only include items starting with "DAT_" (default: all defined data)
    -Preview              Show preview without writing file
    -Help                 Show this help message

EXAMPLES:
    .\extract_ghidra_data_REST.ps1
    .\extract_ghidra_data_REST.ps1 -DllName "D2Client.dll"
    .\extract_ghidra_data_REST.ps1 -DllName "D2Game.dll" -Preview
    .\extract_ghidra_data_REST.ps1 -DATOnly
    .\extract_ghidra_data_REST.ps1 -DllName "Packets.dll" -OutputFile "PacketsDataTodo.txt"
    .\extract_ghidra_data_REST.ps1 -Limit 10000

DESCRIPTION:
    Extracts defined data items from Ghidra using the list_data_items_by_xrefs REST endpoint
    and formats them as "[ ] name @ address (N xrefs)" for todo tracking.

    This tool uses the optimized list_data_items_by_xrefs endpoint which:
    - Returns data already sorted by xref count (highest first)
    - Excludes items with 0 xrefs automatically
    - Provides JSON format with complete metadata

    Use -DATOnly to filter only items starting with "DAT_".

ADVANTAGES OVER OLD VERSION:
    - Single API call instead of N+1 calls (one per data item for xrefs)
    - Pre-sorted by xref count on server side
    - Excludes 0-xref items automatically
    - JSON parsing for reliable data extraction
    - Dramatically faster execution time
"@
    exit 0
}

if ($Help) {
    Show-Help
}

Write-Host "GHIDRA DATA EXTRACTOR - list_data_items_by_xrefs VERSION" -ForegroundColor Green
Write-Host "=========================================================" -ForegroundColor Green
Write-Host "Output file: $OutputFile"
Write-Host "Ghidra URL: $GhidraUrl"
Write-Host "Limit: $Limit"
Write-Host "DAT_ only: $DATOnly"
Write-Host ""

try {
    # Construct URL for the list_data_items_by_xrefs endpoint
    # Format: /list_data_items_by_xrefs?offset=0&limit=5000&format=json
    $endpoint = "$GhidraUrl/list_data_items_by_xrefs"
    $params = @{
        offset = 0
        limit = $Limit
        format = "json"
    }

    # Build query string
    $queryString = ($params.GetEnumerator() | ForEach-Object { "$($_.Key)=$($_.Value)" }) -join "&"
    $requestUrl = "$endpoint`?$queryString"

    Write-Host "Fetching data items from Ghidra..." -ForegroundColor Blue
    Write-Host "Request URL: $requestUrl" -ForegroundColor Cyan

    # Make REST API call
    $response = Invoke-WebRequest -Uri $requestUrl -Method GET -TimeoutSec 60

    if ($response.StatusCode -eq 200) {
        Write-Host "Response received: $($response.Content.Length) characters" -ForegroundColor Green

        # Parse JSON response
        # Expected format: array of objects with fields: address, name, type, size, xref_count
        # Example:
        # [
        #   {
        #     "address": "0x6fb835b8",
        #     "name": "DataTableName",
        #     "type": "pointer",
        #     "size": "4 bytes",
        #     "xref_count": 25
        #   },
        #   ...
        # ]

        $dataItems = $response.Content | ConvertFrom-Json

        if (-not $dataItems -or $dataItems.Count -eq 0) {
            Write-Host "No data items found" -ForegroundColor Yellow

            if (-not $Preview) {
                # Create empty file with header
                $header = @(
                    "# $DllName Data Todo List"
                    "# Format: [ ] name @ address (N xrefs)"
                    "# Generated by extract_ghidra_data_REST.ps1 on $(Get-Date)"
                    "# Using list_data_items_by_xrefs endpoint"
                    "# No data items found"
                    "#"
                    ""
                )
                $header | Out-File -FilePath $OutputFile -Encoding UTF8
            }
            exit 0
        }

        Write-Host "Parsed $($dataItems.Count) data items from JSON" -ForegroundColor Green

        # Apply DAT_ filter if requested
        if ($DATOnly) {
            $filteredItems = $dataItems | Where-Object { $_.name -like "DAT_*" }
            Write-Host "Filtered to $($filteredItems.Count) DAT_ items" -ForegroundColor Cyan
        } else {
            $filteredItems = $dataItems
        }

        # Format as todo items
        # Data is already sorted by xref_count (highest first) from the API
        $formattedItems = $filteredItems | ForEach-Object {
            # Extract address without 0x prefix for consistency
            $addr = $_.address -replace '^0x', ''
            "[ ] $($_.name) @ $addr ($($_.xref_count) xrefs)"
        }

        Write-Host ""
        Write-Host "WRITING RESULTS..." -ForegroundColor Green

        if ($formattedItems.Count -gt 0) {
            if ($Preview) {
                Write-Host "PREVIEW MODE - First 10 data items (sorted by xrefs):" -ForegroundColor Cyan
                $formattedItems | Select-Object -First 10 | ForEach-Object { Write-Host "  $_" }
                if ($formattedItems.Count -gt 10) {
                    Write-Host "  ... and $($formattedItems.Count - 10) more data items"
                }
            } else {
                Write-Host "Writing $($formattedItems.Count) data items to $OutputFile..." -ForegroundColor Green

                # Create header for the file
                $header = @(
                    "# $DllName Data Todo List"
                    "# Format: [ ] name @ address (N xrefs)"
                    "# Generated by extract_ghidra_data_REST.ps1 on $(Get-Date)"
                    "# Using list_data_items_by_xrefs endpoint (v1.7.4+)"
                    "# Total data items: $($formattedItems.Count)"
                    "# Total items fetched: $($dataItems.Count)"
                    "# Sorted by xref count (highest first)"
                    "# Items with 0 xrefs excluded by API"
                    "#"
                    ""
                )

                # Write to file
                ($header + $formattedItems) | Out-File -FilePath $OutputFile -Encoding UTF8

                Write-Host "SUCCESS! $($formattedItems.Count) data items written to $OutputFile" -ForegroundColor Green
            }
        } else {
            Write-Host "No data items to write after filtering" -ForegroundColor Yellow

            if (-not $Preview) {
                # Create file with header
                $header = @(
                    "# $DllName Data Todo List"
                    "# Format: [ ] name @ address (N xrefs)"
                    "# Generated by extract_ghidra_data_REST.ps1 on $(Get-Date)"
                    "# Using list_data_items_by_xrefs endpoint"
                    "# Total items fetched: $($dataItems.Count)"
                    "# No items matched filter criteria"
                    "#"
                    ""
                )
                $header | Out-File -FilePath $OutputFile -Encoding UTF8
            }
        }

        Write-Host ""
        Write-Host "STATISTICS:" -ForegroundColor Green
        Write-Host "  Total data items fetched: $($dataItems.Count)"
        Write-Host "  Data items after filter: $($filteredItems.Count)"
        if ($DATOnly) {
            Write-Host "  DAT_ filter: ENABLED"
        }
        Write-Host "  Output file: $OutputFile"
        if (Test-Path $OutputFile) {
            $fileSize = (Get-Item $OutputFile).Length
            Write-Host "  File size: $fileSize bytes"
        }

    } else {
        Write-Host "ERROR: HTTP $($response.StatusCode) - $($response.StatusDescription)" -ForegroundColor Red
    }

} catch {
    Write-Host "ERROR: Exception occurred: $($_.Exception.Message)" -ForegroundColor Red

    if ($_.Exception.InnerException) {
        Write-Host "Inner Exception: $($_.Exception.InnerException.Message)" -ForegroundColor Red
    }

    # Check if it's a connection error
    if ($_.Exception.Message -like "*Unable to connect*" -or $_.Exception.Message -like "*refused*") {
        Write-Host ""
        Write-Host "TROUBLESHOOTING:" -ForegroundColor Yellow
        Write-Host "1. Make sure Ghidra is running with GhidraMCP plugin loaded"
        Write-Host "2. Verify a program is loaded in CodeBrowser"
        Write-Host "3. Verify the URL: $GhidraUrl"
        Write-Host "4. Check if port 8089 is accessible"
        Write-Host "5. Try: Test-NetConnection -ComputerName 127.0.0.1 -Port 8089"
        Write-Host "6. Test endpoint: curl http://127.0.0.1:8089/check_connection"
    }

    # Check if it's a JSON parsing error
    if ($_.Exception.Message -like "*ConvertFrom-Json*") {
        Write-Host ""
        Write-Host "JSON PARSING ERROR:" -ForegroundColor Yellow
        Write-Host "The response from Ghidra may not be valid JSON."
        Write-Host "Response content (first 500 chars):"
        if ($response) {
            Write-Host $response.Content.Substring(0, [Math]::Min(500, $response.Content.Length))
        }
    }
}

Write-Host ""
Write-Host "EXTRACTION COMPLETE!" -ForegroundColor Green
