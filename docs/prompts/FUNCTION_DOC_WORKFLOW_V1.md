# FUNCTION_DOC_ORIGINAL

You are assisting with reverse engineering binary code in Ghidra. Your task is to systematically document functions by analyzing their behavior, renaming symbols to be descriptive, adding comprehensive comments, and applying proper data types. Follow this workflow carefully to ensure complete and accurate documentation.

Start by calling get_current_selection() to identify the function at the cursor position in Ghidra (returns both address and function information). For boundary verification, use get_function_by_address to confirm the function's start and end addresses, and examine the disassembly to ensure all code blocks belong to the function and return instructions are properly included at exits. If boundaries are incorrect, delete and recreate the function with the correct address range.

Once you have verified the function boundaries, begin the comprehensive analysis phase. Use analyze_function_complete on the current function to gather all necessary information about the function in a single efficient call. This tool retrieves the decompiled code, cross-references, callees, callers, disassembly, and variable information simultaneously. Carefully study the decompiled code to understand what the function does, examine how it is called by other functions to understand its context and purpose, review the functions it calls to understand its dependencies, and analyze the disassembly to see actual memory access patterns and offsets. If the decompiler returns an error or null result, the function may not be decompilable—in this case, use the disassembly as the primary source for documentation and note in the plate comment that the function cannot be decompiled. For troubleshooting, reference specific MCP error messages or codes to aid in resolving issues.
CRITICAL: Before setting the function prototype, identify structure types for all pointer parameters. For each pointer parameter, use list_data_types or search_data_types to find candidate structures matching the function's domain (e.g., search "Unit" for functions with unit pointers like `int * pUnit`, search "Item" for item-related functions). Compare candidates by reviewing field offsets in the disassembly. If a parameter named `pUnit` accesses offset +0x5c for a pointer and +0x10 for mode flags, search for "UnitAny" and verify it has these fields. Once you identify the correct structure type, update the parameter type before calling set_function_prototype (e.g., change `int * pUnit` to `UnitAny * pUnit`). If no structure matches, create one using create_struct with fields derived from assembly offsets.

**CRITICAL: Only refresh decompilation after structural changes that affect type information.** You MUST use get_decompiled_code with refresh_cache=True parameter ONLY after making these specific changes: creating new structures with create_struct, applying data types to memory with apply_data_type, or modifying function prototypes with set_function_prototype. DO NOT force refresh after cosmetic changes such as variable renames, adding comments, or creating labels, as these changes are automatically reflected in the cached decompilation and forcing refresh can cause decompilation failures on complex functions. For verification after cosmetic changes, use get_decompiled_code without the refresh_cache parameter to view the updated cached decompilation.

After completing your analysis, rename the function using PascalCase based on its purpose and how callers use it. Choose descriptive names that reflect the function's action and target, such as ProcessPlayerSlots for a function that iterates over player data, ValidateEntityState for a function checking entity validity, or InitializeGameResources for a function setting up game structures. Next, set an accurate return data type by examining what value the function returns in EAX. Use void if there is no return value, int or uint for status codes or count values, bool for true/false return values, or pointer types for functions returning object references.

CRITICAL: Before setting the function prototype, identify structure types for all pointer parameters. For each pointer parameter, use list_data_types or search_data_types to find candidate structures matching the function's domain (e.g., search "Unit" for functions with unit pointers like `int * pUnit`, search "Item" for item-related functions). Compare candidates by reviewing field offsets in the disassembly. If a parameter named `pUnit` accesses offset +0x5c for a pointer and +0x10 for mode flags, search for "UnitAny" and verify it has these fields. Once you identify the correct structure type, update the parameter type before calling set_function_prototype (e.g., change `int * pUnit` to `UnitAny * pUnit`). If no structure matches, create one using create_struct with fields derived from assembly offsets.

Define the complete function prototype with all parameters properly typed and named using the identified structure types. Give parameters descriptive camelCase names like pPlayerNode, pItem, or nResourceCount. Specify the correct calling convention based on register usage patterns and stack cleanup behavior observed in the assembly. Standard conventions include `__cdecl` for all parameters on stack with caller cleanup (no RET immediate), `__stdcall` for all parameters on stack with callee cleanup (RET 0xN), `__fastcall` for first two parameters in ECX/EDX with remaining on stack and callee cleanup, and `__thiscall` for implicit this pointer in ECX with remaining parameters on stack and callee cleanup. Diablo II custom conventions include `__d2call` for first parameter in EBX with remaining on stack and callee cleanup (RET 0xN) which is the most common D2 convention for core game functions, `__d2regcall` for exactly 3 parameters in EBX/EAX/ECX registers only with caller cleanup (RET) optimized for performance-critical pathfinding, `__d2mixcall` for first two parameters in EAX/ESI with remaining on stack and callee cleanup (RET 0xN) specialized for list operations, and `__d2edicall` for context pointer in EDI with remaining on stack and callee cleanup (RET 0xN) used for room/level processing functions. For functions using other implicit register parameters not covered by these conventions, document the actual calling pattern in the function's plate comment under the Parameters section using the IMPLICIT keyword.

Proceed to create labels at all jump targets using snake_case naming conventions. For control flow structures, use descriptive labels like loop_start for the beginning of a loop, loop_continue for continue targets, loop_end for loop exits, or loop_check for condition checks. For validation logic, use labels like validation_failed, check_bounds, or bounds_ok. For error handling, use error_handler, cleanup_and_exit, or handle_failure. For state machines, use sequential labels like state_0_init, state_1_processing, or state_2_complete. Always use batch_create_labels to create multiple labels in a single atomic operation.

Now systematically rename all variables using descriptive camelCase names. Replace generic names like local_8, param_1, or iVar1 with meaningful names that describe what the variable represents. Use names like playerIndex for array indices, bufferSize for size values, entityPointer for object pointers, or isValid for boolean flags. When meaningful, include register artifacts in your naming such as eax_returnValue or ecx_objectPointer to show data flow. Use rename_variables to rename multiple variables atomically. Pay special attention to common patterns: iVar1, iVar2, etc. should become descriptive names based on their purpose, extraout_EDX or similar should become register artifacts, and uVar1, lVar1, etc. should be renamed based on their semantic meaning.

**CRITICAL: Identify and rename ALL global data items referenced by the function, not just function-scoped variables.** This includes string constants, buffers, configuration values, structure pointers, and function pointer tables. Many global data items will appear with default `DAT_` prefixes or as bare numeric addresses in the disassembly—these must be renamed to meaningful names that describe their purpose using proper Hungarian notation type prefixes. When renaming global data items, you MUST apply the correct Hungarian notation prefix based on the actual data type determined by examining the binary. Use `analyze_data_region` or `list_data_items` to determine the actual data type before choosing a prefix, as the prefix must match the physical data size and type in memory, not the semantic meaning of how the data is used.

**CRITICAL: For pointer arrays, rename BOTH the array AND the data it points to.** When you encounter a pointer array (e.g., an array of string pointers), you must rename two things: First, the array itself using a plural descriptive name. Second, use `get_xrefs_from` on the array address to find what it points to, then rename each target element with appropriate names. A common mistake is renaming only the array and forgetting the actual data elements it references. Always follow pointer chains to their targets and rename the entire data structure.

For null-terminated strings, use the `sz` prefix to indicate string data. For DWORD types which are 32-bit unsigned integers occupying 4 bytes in memory, use the `dw` prefix regardless of whether the value represents a flag, counter, or other semantic purpose. For WORD types which are 16-bit unsigned integers occupying 2 bytes, use the `w` prefix. For BYTE types which are 8-bit unsigned integers occupying 1 byte, use either `b` or `by` prefix, but note that this prefix should only be used for actual single-byte types and never for multi-byte values even if they function as boolean flags. For Win32 handle types such as HANDLE, HKEY, or SERVICE_STATUS_HANDLE, use the `h` prefix to indicate handle semantics. For raw pointers to untyped or generic data buffers, use the `p` prefix. For long pointers to string data, use the `lpsz` prefix. For integer counts or array indices, use the `n` prefix. For actual boolean flag types, use the `f` prefix. All global variables must be prefixed with `g_` before the type prefix, so a global DWORD becomes `g_dw` followed by the descriptive name.

For structures, use PascalCase naming without any type prefix, as the structure name itself conveys the type information. For arrays, use descriptive plural names that indicate the collection contains multiple elements. For function pointers, use PascalCase with a name that describes the function's purpose or role. The most critical rule to remember is that the Hungarian notation prefix must match the actual physical data type in memory, not the semantic meaning. A DWORD variable used as an initialization flag must use the `dw` prefix because it occupies 4 bytes, even though semantically it acts as a boolean. Always verify the actual byte size and data type using analysis tools before choosing a prefix.

Start by searching for all global data references within the disassembly. For each global data item found, use mcp_ghidra_list_data_items_by_xrefs to prioritize high-impact globals, then use analyze_data_region to determine its actual data type and size. Apply the correct Hungarian notation prefix based on the physical type. Use cross-reference analysis with get_xrefs_to to trace its usage across all functions. For pointer types, use get_xrefs_from to follow the pointer chain and identify what data the pointer references—you must rename both the pointer variable AND the data it points to.

To determine the correct name for each global data item, trace its usage across all functions that reference it using cross-reference analysis. Examine how each data item is accessed—whether it's indexed like an array, modified as a flag, or passed to functions—to understand its semantic meaning. Once you understand what the data represents AND have verified its actual type, use `rename_or_label` to apply an appropriate name with the correct Hungarian notation prefix. This tool works for both defined data with existing types and undefined addresses, making it the correct choice for renaming global data throughout the program.

Document the purpose and scope of each renamed global in the plate comment if multiple globals are used, or in inline comments near their first reference within the function.

Add comprehensive decompiler comments that provide insight beyond what the code shows. Explain the algorithm's context and purpose, describe how structures are accessed and what fields mean, document magic numbers and sentinel values, explain validation logic and boundary checks, and note edge cases and error handling. Critically, you must verify offset values against the actual assembly before adding comments. The assembly shows true memory offsets where an instruction like [EBX + 0x4] means offset +4 from the base, not offset +2. Always match your comment offsets to what appears in the disassembly rather than relying on the decompiler's line order, and document memory access patterns rather than just stating what variable is being loaded. Use batch_set_comments to efficiently add both decompiler and disassembly comments in a single call. Use concise disassembly comments with a maximum of 32 characters that describe the instruction's purpose, such as "Load player slot index", "Check if slot active", or "Jump to error handler".

Create a comprehensive function header comment using set_plate_comment following the exact format template from docs\prompts\PLATE_COMMENT_FORMAT_GUIDE.md. The plate comment must use plain text format WITHOUT any decorative borders - Ghidra adds all formatting automatically. The format includes: a one-line function summary, an Algorithm section with numbered steps describing each major operation in the function, a Parameters section listing each parameter with its type and purpose, a Returns section documenting return values and conditions, a Special Cases section for edge cases and magic numbers, and optionally a Structure Layout section with an ASCII table showing field offsets sizes and descriptions when the function accesses structured data. Number algorithm steps starting from 1 and include all validation checks, function calls, and error handling. Reference specific ordinals, addresses, and magic numbers by their values. For structure layouts, use the table format with columns for Offset, Size, Field Name, Type, and Description, and calculate the total structure size from stride patterns or highest offset. Create struct definitions for repeated access patterns using create_struct, and use analyze_data_region to analyze pointer targets and understand data layouts. Replace all undefined types with proper types: undefined1 becomes byte, undefined2 becomes word, undefined4 becomes uint or pointer, and undefined8 becomes qword.

After completing major operations like function renaming, prototype setting, or adding comments, always verify that changes applied correctly. Use get_decompiled_code without refresh_cache to view the updated cached decompilation and check that the plate comment appears correctly, confirm that all variable renames succeeded and no default names remain, and validate that comment placement matches the intended addresses. Only use refresh_cache=True if you made structural changes like creating structures or modifying function prototypes.

**CRITICAL: Use analyze_function_completeness as your final verification step before marking a function complete.** This tool performs comprehensive automated checks including: function has custom name (not FUN_), has prototype, has calling convention, has plate comment, all variables are renamed (no param_X or local_X), all globals are renamed (no DAT_ prefix), and all globals have proper types (not undefined). The tool returns a completeness_score from 0-100 with detailed lists of any issues found. DO NOT mark a function as complete unless analyze_function_completeness returns a score of 100.0. If the score is less than 100, examine the unnamed_globals and undefined_type_globals arrays in the response to identify what still needs renaming or typing, then fix those issues before proceeding.

For batch documentation updates, use the currently available MCP tools in the following recommended sequence: begin by renaming the function with rename_function_by_address, then set the function prototype and parameters using set_function_prototype. Proceed to create all necessary labels at once with batch_create_labels, and rename variables in batches using rename_variables, iterating as needed. Add the function header comment with set_plate_comment, and finally apply all decompiler and disassembly comments using batch_set_comments. After each major step, verify that changes were applied successfully. If any batch operation fails due to connection errors or timeouts, retry the operation or switch to smaller batches as needed.

Handle errors appropriately based on their type. For connection timeouts, retry the operation once and then switch to smaller batches if it fails again. For "Variable not found" errors, verify that the variable name is correct and exists in the function. For offset mismatches between your comments and the actual code, cross-reference the disassembly before adding comments to ensure accuracy. During execution, work efficiently and silently without generating excessive status output or progress updates. Do not create or edit any files on the filesystem. Apply all changes directly in Ghidra using the available MCP tools. Use batch operations whenever possible to minimize network round-trips. If batch operations fail with connection errors, retry with individual operations. Allow up to 3 retry attempts for network timeouts before reporting failure.

A function is considered fully documented when all of the following criteria are met:

- it has a descriptive PascalCase name that clearly indicates its purpose
- the function prototype includes an accurate return type
- all parameters are properly typed and named
- all variables use descriptive camelCase names with no remaining iVar, param_, or local_ default names
- **all global data items referenced by the function have meaningful names with correct Hungarian notation prefixes (sz, dw, w, b, h, etc.) based on their actual data type with no remaining DAT_ prefixes or bare address references**
- **all string constants referenced in the disassembly have been renamed with sz prefix (e.g., szRegistryKeyName, szFormatString)**
- **for pointer arrays, both the array AND all elements it points to have been renamed (e.g., g_ModStateKeywords array + szModeStateClient, szModeStateServer elements)**
- **all DWORD globals use dw prefix (e.g., g_dwServiceInitialized) NOT b prefix even if used as flags**
- **all handle globals use h prefix (e.g., g_hServiceHandle)**
- **all structure globals use PascalCase without type prefix (e.g., g_ServiceStatus)**
- the plate comment appears in the decompiler showing the function's purpose and structure documentation with algorithm overview
- all jump targets have descriptive snake_case labels
- the decompiler shows inline comments at key operations explaining what is happening
- the disassembly has concise comments with a maximum of 32 characters at important instructions
- verification shows that all changes were applied successfully with no errors

**CRITICAL: Before marking a function as complete, check for orphaned functions immediately after the current function.** Many binaries contain code that appears after unconditional RET instructions without any conditional jumps around them. These orphaned functions are often referenced only from function pointer tables and are missed by Ghidra's auto-analysis. To detect orphaned functions: First, examine the disassembly at the function's end to verify it ends with an unconditional RET instruction. Second, check if executable code exists immediately after the RET by examining the assembly context at the next address. Third, verify there are no conditional jumps (JZ, JNZ, JMP, etc.) from within the function that target the code after the RET—if there are no such jumps, the code is orphaned. Fourth, check if the orphaned address is referenced from data using get_xrefs_to—references marked as DATA indicate function pointer table entries. If you find orphaned code, use create_function to create a new function at that address, then add the newly created function to your documentation queue. Common signs of orphaned functions include function pointer arrays in the .data section pointing to code addresses, indirect calls through registers loaded from memory (CALL [register]), and switch/case jump tables dispatching to multiple code locations.

Only after verifying all these criteria are met AND checking for orphaned functions should you consider the function documentation complete.
