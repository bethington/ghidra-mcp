# FUNCTION_DOC_PARAGRAPHS

You are assisting with reverse engineering binary code in Ghidra. Your task is to systematically document functions with complete accuracy and comprehensive detail. This workflow follows a logical sequence: establish execution guidelines, initialize and analyze the function, identify structures early, name and type all elements, create comprehensive documentation, and verify completeness. Each section builds on the previous one to ensure you document functions correctly the first time without rework.

## Execution Guidelines and Best Practices

For batch documentation updates, use the currently available MCP tools in the following recommended sequence: begin by renaming the function with rename_function_by_address, then set the function prototype and parameters using set_function_prototype. Proceed to create all necessary labels at once with batch_create_labels, and rename variables in batches using rename_variables, iterating as needed. Add the function header comment with set_plate_comment, and finally apply all decompiler and disassembly comments using batch_set_comments. After each major step, verify that changes were applied successfully. If any batch operation fails due to connection errors or timeouts, retry the operation or switch to smaller batches as needed.

Handle errors appropriately based on their type. For connection timeouts, retry the operation once and then switch to smaller batches if it fails again. For "Variable not found" errors, verify that the variable name is correct and exists in the function. For offset mismatches between your comments and the actual code, cross-reference the disassembly before adding comments to ensure accuracy. During execution, work efficiently and silently without generating excessive status output or progress updates. Do not create or edit any files on the filesystem. Apply all changes directly in Ghidra using the available MCP tools. Use batch operations whenever possible to minimize network round-trips. If batch operations fail with connection errors, retry with individual operations. Allow up to 3 retry attempts for network timeouts before reporting failure.

## Initialization and Boundary Verification

Start by calling get_current_selection() to identify the function at the cursor position in Ghidra (returns both address and function information). For boundary verification, use get_function_by_address to confirm the function's start and end addresses, and examine the disassembly to ensure all code blocks belong to the function and return instructions are properly included at all exit points. If boundaries are incorrect, delete and recreate the function with the correct address range. This initial verification prevents documentation errors caused by incorrect function scope.

## Comprehensive Analysis Phase

Once you have verified the function boundaries, begin the comprehensive analysis phase by using analyze_function_complete on the current function to gather all necessary information in a single efficient call. This tool retrieves the decompiled code, cross-references (both to and from), callees (functions this function calls), callers (functions that call this function), disassembly, and variable information (parameters and locals) simultaneously. Carefully study the decompiled code to understand what the function does, examine how it is called by other functions to understand its context and purpose, review the functions it calls to understand its dependencies, and analyze the disassembly to see actual memory access patterns and offsets. If the decompiler returns an error or null result, the function may not be decompilable—in this case, use the disassembly as the primary source for documentation and note in the plate comment that the function cannot be decompiled.

After retrieving the function information, you MUST perform a mandatory undefined type audit by systematically examining BOTH the decompiled code and the disassembly view for any undefined types that require resolution. First, check the decompiled code output from analyze_function_complete for undefined types including undefined return types (undefined4, undefined8, undefined1), undefined local variables (undefined4 local_c, undefined1[10] auVar16), undefined parameters (undefined4 param_1), and undefined structure field types. Second, and critically, examine the disassembly output to identify variables that appear ONLY in assembly context such as stack-based temporaries referenced with patterns like [EBP + local_offset] that may not appear in get_function_variables, XMM register spills to stack locations like undefined1[16] at [ESP + offset], intermediate calculation results stored to stack slots, and structure field accesses at specific offsets like [EAX + 0x10]. Many undefined types exist exclusively in the assembly view and will NOT appear in the decompiled code variable list—you must check the disassembly directly to catch these cases. Third, use get_function_variables to retrieve the formal variable list and cross-reference it against what you observed in both views to identify any discrepancies where variables appear in assembly but not in the variable table. Fourth, create a comprehensive type resolution plan listing every undefined type found in either view, its observed usage pattern, and the correct lowercase builtin type it should become (undefined4 used as counter → int, undefined4 used as flags → uint, undefined1[10] for FPU values → byte[10], undefined4 dereferenced as pointer → typed pointer like UnitAny *). Only after completing this mandatory audit and resolving ALL undefined types in both decompiled and assembly views should you proceed to the variable renaming phase. This systematic checkpoint prevents the common error of documenting functions while leaving undefined types in assembly that were not visible in the decompiled variable list.

## Structure Type Identification (CRITICAL - Do This First)

Before proceeding to any documentation or renaming, you must identify all structure types accessed by the function. This is critical because creating structures first ensures field accesses are documented with meaningful names rather than raw offsets, and prevents inconsistencies where different functions document the same structure fields differently. For functions that access structured data through pointer arithmetic and offsets, analyze all offset accesses in the function and search for existing structures using list_data_types to find candidate structures matching the function's domain (for example, search "Unit" for functions with unit pointers like int * pUnit, or search "Item" for item-related functions). Use get_struct_layout to review field layouts and compare field offsets in the disassembly with structure definitions. If a parameter named pUnit accesses offset +0x5c for a pointer and +0x10 for mode flags, search for "UnitAny" and verify it has fields at these offsets. If no matching structure exists, create one using create_struct with fields derived from assembly offsets, and verify the structure size matches the stride or allocation size used in the code. Document the structure layout in a formatted table within the plate comment with columns for Offset, Size, Field Name, Type, and Description, and calculate the total structure size from stride patterns or highest offset. Only after structures are properly defined should you proceed with documenting the function itself.

## Function Naming and Prototype Definition

After completing your analysis and identifying all structures, rename the function using rename_function_by_address with a descriptive PascalCase name based on its purpose and how callers use it. Choose descriptive names that reflect the function's action and target, such as ProcessPlayerSlots for a function that iterates over player data, ValidateEntityState for a function checking entity validity, or InitializeGameResources for a function setting up game structures. Next, set an accurate return data type by examining what value the function returns in EAX: use void if there is no return value, int or uint for status codes or count values, bool for true/false return values, or pointer types for functions returning object references.

Define the complete function prototype using set_function_prototype with all parameters properly typed and named using the identified structure types. Type all pointer parameters with proper structure types (for example, UnitAny * not int *) and give parameters descriptive camelCase names like pPlayerNode, pItem, or nResourceCount. Specify the correct calling convention based on register usage patterns and stack cleanup behavior observed in the assembly. Standard conventions include __cdecl for all parameters on stack with caller cleanup (no RET immediate), __stdcall for all parameters on stack with callee cleanup (RET 0xN), __fastcall for first two parameters in ECX/EDX with remaining on stack and callee cleanup, and __thiscall for implicit this pointer in ECX with remaining parameters on stack and callee cleanup. Diablo II custom conventions include __d2call for first parameter in EBX with remaining on stack and callee cleanup (RET 0xN) which is the most common D2 convention for core game functions, __d2regcall for exactly 3 parameters in EBX/EAX/ECX registers only with caller cleanup (RET) optimized for performance-critical pathfinding, __d2mixcall for first two parameters in EAX/ESI with remaining on stack and callee cleanup (RET 0xN) specialized for list operations, and __d2edicall for context pointer in EDI with remaining on stack and callee cleanup (RET 0xN) used for room/level processing functions. For functions using other implicit register parameters not covered by these conventions, document the actual calling pattern in the function's plate comment under the Parameters section using the IMPLICIT keyword.

After setting the prototype, use get_decompiled_code with refresh_cache=True to update the decompilation with new type information. This refresh is critical because it propagates the new structure types through the decompilation. However, you MUST use refresh_cache=True ONLY after making structural changes that affect type information: creating new structures with create_struct, applying data types to memory with apply_data_type, or modifying function prototypes with set_function_prototype. DO NOT force refresh after cosmetic changes such as variable renames, adding comments, or creating labels, as these changes are automatically reflected in the cached decompilation and forcing refresh can cause decompilation failures on complex functions.

## Label Creation at Control Flow Targets

Proceed to create labels at all jump targets using batch_create_labels to create multiple labels in a single atomic operation. Use snake_case naming conventions: for control flow structures, use descriptive labels like loop_start for the beginning of a loop, loop_continue for continue targets, loop_end for loop exits, or loop_check for condition checks; for validation logic, use labels like validation_failed, check_bounds, or bounds_ok; for error handling, use error_handler, cleanup_and_exit, or handle_failure; and for state machines, use sequential labels like state_0_init, state_1_processing, or state_2_complete.

## Hungarian Notation Type System (Shared Foundation)

All variables—both local function-scoped variables and global data items—must have their types properly set and then be renamed with proper Hungarian notation type prefixes that match their actual data type. This two-step process ensures both the Ghidra database and the variable names reflect accurate type information. This requirement applies to both the disassembled code view and the decompiled code view in Ghidra. The following type normalization rules, type-to-prefix mappings, and consistency verification procedures apply universally to all variable renaming operations.

Before setting types and applying Hungarian notation, you must first normalize all uppercase Windows SDK types to lowercase builtin types to ensure consistency and leverage Ghidra's builtin type prioritization. When examining variable types (from get_function_variables for locals or from list_data_items for globals), if you see uppercase types like UINT, USHORT, DWORD, BYTE, or other Windows SDK types from WinDef.h, you MUST convert them to their lowercase builtin equivalents: UINT becomes uint, USHORT becomes ushort, DWORD becomes uint (since DWORD is typedef'd as unsigned long which is 4 bytes = uint), BYTE becomes byte, WORD becomes ushort, and BOOL becomes bool. This normalization ensures that the builtin type system takes precedence over Windows SDK types, provides consistent type naming across the entire codebase, and aligns with the builtin type prioritization logic implemented in the resolveDataType method which searches for builtin types first before falling back to category-based types like those in WinDef.h. When setting variable types (with set_local_variable_type for locals or apply_data_type for globals), always use lowercase builtin type names (uint, ushort, byte) rather than uppercase Windows types (UINT, USHORT, BYTE) to ensure you're working with Ghidra's core type system.

After normalizing types to lowercase builtins, apply Hungarian notation prefixes based on the physical data type using this definitive type-to-prefix mapping which ensures that Hungarian notation prefixes always match the actual Ghidra type. For byte types (1 byte), use prefix b or by for 8-bit unsigned integers. For char types (1 byte), use prefix c or ch for 8-bit characters (signed or unsigned). For bool types (1 byte), use prefix f for boolean flags (use f not b). For short types (2 bytes), use prefix n or s for 16-bit signed integers. For ushort types (2 bytes), use prefix w for 16-bit unsigned integers (WORD). For int types (4 bytes), use prefix n or i for 32-bit signed integers. For uint types (4 bytes), use prefix dw for 32-bit unsigned integers (DWORD). For long types (4 bytes), use prefix l for 32-bit signed long. For ulong types (4 bytes), use prefix dw for 32-bit unsigned long (same as DWORD). For longlong types (8 bytes), use prefix ll for 64-bit signed integers. For ulonglong types (8 bytes), use prefix qw for 64-bit unsigned integers (QWORD). For float types (4 bytes), use prefix fl for 32-bit floating point. For double types (8 bytes), use prefix d for 64-bit floating point. For float10 types (10 bytes), use prefix ld for 80-bit extended precision float. For void pointer types (4 bytes), use prefix p for generic pointers (32-bit). For typed pointer types (4 bytes), use prefix p followed by the structure name for typed pointers (pUnitAny, pFileHandle). For HANDLE types (4 bytes), use prefix h for Win32 handle types. For byte array types (N bytes), use prefix ab for arrays of bytes (abXmmBuffer, abTempStorage). For ushort array types (N*2 bytes), use prefix aw for arrays of words (awTableEntries). For uint array types (N*4 bytes), use prefix ad for arrays of dwords (adOffsetTable). For char pointer types (4 bytes), use prefix sz for null-terminated string pointers (szFilename, szErrorMessage) or prefix lpsz for long pointers to strings (lpszCommandLine). For wchar_t pointer types (4 bytes), use prefix wsz for wide string pointers (wszUnicodePath). For structure types (varies), use the structure name itself in camelCase without any type prefix (unitAny, playerData) since the structure name conveys the type information. For function pointer types (4 bytes), use PascalCase with a name that describes the function's purpose or role without any type prefix (ProcessInputEvent, ValidatePacket).

For global variables specifically, all variable names must be prefixed with g_ before the type prefix, so a global uint becomes g_dw followed by the descriptive name (g_dwProcessId, g_dwFlags), a global byte array becomes g_ab followed by the descriptive name (g_abEncryptionKey), a global structure uses g_ followed by PascalCase naming without any type prefix (g_ServiceStatus, g_CurrentGameState), global string constants use g_sz prefix (g_szConfigPath, g_szErrorMessage) or szConstantName without g_ if the string is a true constant rather than mutable data, global arrays use descriptive plural names that indicate the collection contains multiple elements (g_adPlayerSlots, g_awPortNumbers), and function pointers use PascalCase without g_ prefix (ProcessInputEvent, ValidatePacket) as these are typically in code sections rather than data sections.

Use these mappings as your authoritative reference when setting types and renaming variables. The Hungarian prefix MUST match the Ghidra type exactly: if the type is uint, the prefix must be dw; if the type is ushort, the prefix must be w; if the type is byte, the prefix must be b or by. After completing all variable renames, perform a type-to-prefix consistency verification by comparing the Hungarian prefix in each variable name against the actual type shown in the variable listing—any mismatches indicate either an incorrect type assignment or an incorrect prefix choice, both of which must be corrected to maintain documentation accuracy.

For both local and global variables, you must set the correct type before applying Hungarian notation. Replace undefined types with proper types: replace undefined1 with byte for 8-bit values, replace undefined2 with ushort or short for 16-bit values, replace undefined4 with uint, int, float, or pointer types (like float10 *) for 32-bit values, and replace undefined8 with double, ulonglong, or longlong for 64-bit values. For array types, replace undefined1[N] with byte[N] to indicate byte arrays (commonly used for XMM register spills and buffer storage), replace undefined2[N] with ushort[N] or word[N] for word arrays, and replace undefined4[N] with uint[N] or dword[N] for dword arrays. For pointer types, specify the complete pointer declaration including the pointed-to type (for example, "float10 *" not just "pointer"). Setting types first ensures that Hungarian notation prefixes align with Ghidra's internal type information, improving decompilation quality and making the code more understandable.

For example, if you see a variable with type UINT (uppercase), first set its type to uint (lowercase) using the appropriate type-setting tool, then rename it with the dw prefix (dwFlags, dwTableIndex for locals, or g_dwProcessId for globals). If you see type USHORT, set it to ushort and use the w prefix (wStatus, wExponentMask for locals, or g_wServiceStatus for globals). If you see type undefined4 used as a flag variable, set it to uint (not UINT) and rename with dw prefix (dwMantissaShiftAmount for locals, or g_dwFlags for globals). If you see type undefined1[16] used for XMM register storage, set it to byte[16] (not BYTE[16]) and rename with ab prefix (abXmmBuffer for locals, or g_abEncryptionKey for globals). This systematic approach ensures that both the Ghidra database type and the variable name prefix accurately reflect the actual data type, and that lowercase builtin types take precedence over uppercase Windows SDK types throughout the codebase.

## Local Variable Renaming and Type-Setting with Hungarian Notation

For local function-scoped variables, apply the shared Hungarian notation type system defined above with the following local-specific workflow and considerations. Local variables do not use the g_ scope prefix and have specific renameability limitations based on Ghidra's decompiler architecture.

First, use get_function_variables to retrieve the complete list of stack-based locals and parameters. Examine each variable's current type and apply the type normalization and type-to-prefix mapping rules from the shared Hungarian notation type system defined above. Use set_local_variable_type to set the correct lowercase builtin type for each variable based on how it's used in the code, following the type replacement rules for undefined types.

To rename variables efficiently and reliably, follow this critical workflow that ALWAYS attempts renaming first before assuming any variable is non-renameable. First, examine the decompiled code to identify ALL variables present in the function, including those with patterns like in_ST0, in_XMM0, iVar1, uVar1, dVar12, local_c, and param_1—do NOT assume any variable cannot be renamed based solely on its name pattern. Many variables with in_ prefixes (such as in_ST0 for FPU stack parameters, in_EAX for register parameters, or in_XMM0 for SSE parameters) CAN be successfully renamed despite appearing to be implicit parameters. Similarly, SSA-generated variables (iVar1, uVar2, dVar12) are often renameable even though they have synthetic names. Second, set the correct type for each variable using set_local_variable_type, normalizing undefined types to lowercase builtins (undefined4 to int or uint, undefined1 to byte, keeping float10 for extended precision). Third, apply Hungarian notation based on the actual data type and create a complete rename dictionary for ALL variables you identified. Fourth, attempt to rename all variables in batches using rename_variables with the variable_renames dictionary containing all your mappings—do NOT exclude variables based on name patterns. Fifth, after each batch rename operation, check the returned variables_renamed count in the response—this count tells you how many variables were ACTUALLY renamed successfully. If variables_renamed equals the number you attempted, all renames succeeded and the variables now have proper Hungarian notation in both disassembly and decompiled views. If variables_renamed is less than attempted, some variables could not be renamed—only these specific variables are truly non-renameable and should be documented using decompiler comments explaining what they represent. For variables that return variables_renamed of 0 after attempting rename, these are decompiler-synthesized variables that don't exist in the variable table, typically due to storage reuse or complex SSA analysis. The key principle is that the variables_renamed count is the ONLY reliable indicator of whether a variable can be renamed—never assume non-renameability based on name patterns, and never skip attempting to rename variables with in_ prefixes or SSA-generated names. Finally, verify that the changes appear correctly in both the disassembly (where stack offsets and register references show renamed variables) and the decompiled code output by viewing the updated decompilation.

However, be aware that Ghidra's decompiler has architectural limitations with certain variable types. The decompiler generates synthetic variable names (like dVar12, dVar13, iVar1, uVar3) based on SSA (Static Single Assignment) analysis of data flow, not based on the underlying storage location names. Whether these synthetic variables can be renamed depends on storage reuse patterns: lower-numbered compiler-generated variables (like iVar1, iVar2, dVar1, dVar8, dVar9, lVar3, uVar4) typically represent the first use of a storage location and CAN be renamed, while higher-numbered variables (like dVar19, dVar21-25, lVar6, lVar8, uVar7, uVar11) often represent reused storage locations where the same register or stack slot is repurposed for a different semantic purpose later in the function, and these reused instances CANNOT be renamed because they are decompiler-synthesized views of already-named storage. When attempting to rename variables, use get_function_variables first to see which variables exist in Ghidra's actual variable table—only variables in this list can be renamed. The rename_variables tool will return "variables_renamed": 0 for variables that don't exist in the table, even though it reports "success": true, so always check the variables_renamed count to verify that renames actually occurred. Additionally, some variable types are non-renameable and will retain their generated names: register-based implicit parameters prefixed with "in_" followed by a register name and type suffix (such as in_XMM0, in_XMM1_Qa, in_XMM2_Qa, in_XMM3_Qa, in_EAX, in_EDX, in_ECX) which represent parameters passed through registers; register-based implicit return values prefixed with "extraout_" or "output_" (such as extraout_EAX, extraout_XMM0) which represent values returned in registers; stack-passed parameters prefixed with "in_stack_" (such as in_stack_00000008, in_stack_0000000c) which represent arguments passed through the stack; and undefined array types with square bracket notation (such as auVar16[16], auVar17[16]) which represent compiler-generated temporary arrays or SSE register spills. For these non-renameable variables, adopt a comment-driven documentation strategy: add comprehensive decompiler comments that explain each variable's purpose with Hungarian notation type information in the comment text, such as "in_XMM1_Qa (qwBaseExponent): Quad precision floating-point parameter passed in XMM1 register representing the base exponent value" or "dVar12 (dwExtractedBits): Holds extracted exponent bits used for table index calculation" or "auVar16[16] (abXMMBuffer): SSE register spill buffer for 128-bit XMM operations". This hybrid approach ensures that renameable local variables get proper Hungarian notation in their actual names visible in both disassembly and decompiled views, while non-renameable variables receive equivalent documentation through inline comments that specify what their Hungarian-notated name would be if renaming were possible. Watch carefully for variable re-use optimization patterns where compilers repurpose storage locations after their initial use to save stack space, and document these patterns prominently in decompiler comments at the point where the variable's semantic meaning changes, noting both the old and new Hungarian-style naming in the comments.

## Global Data Renaming and Type-Setting with Hungarian Notation

For global data items referenced by the function, apply the shared Hungarian notation type system defined above with the following global-specific workflow and considerations. Global variables require the g_ scope prefix before the type prefix, and renaming uses different tools than local variables.

Identify and rename ALL global data items referenced by the function, not just function-scoped variables. This includes string constants, buffers, configuration values, structure pointers, and function pointer tables. Many global data items will appear with default DAT_ prefixes or as bare numeric addresses in the disassembly—these must be renamed to meaningful names that describe their purpose using proper Hungarian notation type prefixes. When renaming global data items, you MUST apply the correct Hungarian notation prefix based on the actual data type determined by examining the binary, as the prefix must match the physical data size and type in memory, not the semantic meaning of how the data is used.

Start by searching for all global data references within the disassembly. For each global data item found, use list_data_items_by_xrefs to prioritize high-impact globals, then use analyze_data_region to determine its actual data type and size. Before renaming, set the proper data type using apply_data_type to replace undefined types with accurate type information following the type replacement rules from the shared Hungarian notation type system. Setting the type first ensures that Ghidra's analysis and cross-references accurately reflect the data's purpose and size. After setting the type, apply the correct Hungarian notation prefix based on the physical type using the type-to-prefix mapping from the shared system. Use cross-reference analysis with get_xrefs_to to trace its usage across all functions. For pointer types, use get_xrefs_from to follow the pointer chain and identify what data the pointer references—you must set the type for and rename both the pointer variable AND the data it points to, as a common mistake is renaming only the array and forgetting to set types for and rename the actual data elements it references. Once you have set the proper type and understand what the data represents, use rename_or_label to apply an appropriate name with the correct Hungarian notation prefix (this tool works for both defined data with existing types and undefined addresses).

When documenting structure offsets and array strides, establish a consistent documentation pattern that clearly distinguishes between byte offsets, element indices, and calculated addresses. For example, when documenting code like [EBX + EAX*0x24 + 0x4], break down the address calculation explicitly: "EBX (base of file descriptor table) + EAX*0x24 (descriptor index × 36-byte stride) + 0x4 (offset to flags field within descriptor)" rather than simply stating "access flags field." This detailed breakdown helps readers understand multi-level data structures where an index is first scaled by a stride to find a structure, then an offset within that structure locates a specific field. Always document the stride value, explain what it represents (structure size, entry size, etc.), and show how indices are scaled before adding field offsets. When structures are accessed through bucket-based indexing schemes like bucket = index >> 5 and offset = (index & 0x1F) * stride, document both the bucket calculation and the within-bucket offset calculation with explicit bit manipulation explanations.

## Cross-Reference Verification for Flags and Bit Fields

When documenting flag bits or bit field structures, you must cross-reference all usage sites to verify that your bit assignments are consistent with how the flags are actually used throughout the codebase. Use get_xrefs_to on the flag variable to find all functions that access it, then examine how each function masks or tests specific bits using instructions like TEST, AND, OR, or bit shift operations. For example, if you document bit 7 as "Binary mode flag (0x80)" but then find another function testing the same flag with a different semantic meaning like "Append mode," this indicates either an error in your documentation or actual flag reuse that must be noted. Create a Flag Usage Cross-Reference subsection in the plate comment listing each function that accesses the flag and what bit operations it performs, which serves both as validation of your bit assignments and as documentation of where the flags are used throughout the program. Document the purpose and scope of each renamed global in the plate comment if multiple globals are used, or in inline comments near their first reference within the function.

## Comprehensive Plate Comment Creation

Create a comprehensive function header comment using set_plate_comment following the exact format template from docs\prompts\PLATE_COMMENT_FORMAT_GUIDE.md. The plate comment must use plain text format WITHOUT any decorative borders—Ghidra adds all formatting automatically. The format includes: a one-line function summary; an Algorithm section with numbered steps (starting from 1) describing each major operation in the function including all validation checks, function calls, and error handling paths; a Parameters section listing each parameter with its type (with structure types, not generic pointers) and purpose, using the IMPLICIT keyword for undocumented register parameters; a Returns section documenting return values and conditions including success values, error codes, and NULL/zero conditions; a Special Cases section for edge cases and exceptional behavior; a Magic Numbers Reference section listing all numeric constants with their hex value, decimal equivalent, and semantic meaning (this section must be included as standard practice whenever the function uses any numeric constants that aren't immediately obvious from context); an Error Handling section (if applicable) mapping all error paths including Windows API error to errno translations, validation failure to error return mappings, and error propagation from called functions; a State Machine section (if complex control flow exists) enumerating all possible execution states and transitions between them; a Structure Layout section (if function accesses structures) with an ASCII table showing field offsets, sizes, and descriptions; and a Flag Bits section (if applicable) with a detailed bit table using consistent hex notation throughout.

When documenting flag bits, status values, or any numeric constants used for comparison or masking, you must establish and maintain consistent notation standards throughout all sections of the documentation. Use hexadecimal format with 0x prefix for all flag values (for example, 0x02, 0x04, 0x80) rather than mixing decimal and hex notation, as consistency eliminates confusion when cross-referencing between algorithm steps, flag bit tables, and inline comments. When creating flag bit tables, align all hex values consistently and use the same bit numbering scheme (either 0-7 or 1-8) throughout the entire documentation. This notation consistency should extend to magic numbers, error codes, and structure sizes—if you document a flag as 0x80 in the algorithm section, use 0x80 in the flag table and 0x80 in inline comments, never switching to decimal 128 or binary 10000000 in different sections.

Reference specific ordinals, addresses, and magic numbers by their values in the Algorithm section. For structure layouts, use the table format with columns for Offset, Size, Field Name, Type, and Description, and calculate the total structure size from stride patterns or highest offset. Create struct definitions for repeated access patterns using create_struct, and use analyze_data_region to analyze pointer targets and understand data layouts. Replace all undefined types with proper types: undefined1 becomes byte, undefined2 becomes word, undefined4 becomes uint or pointer, and undefined8 becomes qword.

## Algorithm Logic Verification (CRITICAL)

After creating the comprehensive plate comment with numbered algorithm steps, you must immediately verify each step against the actual decompiled code and assembly to ensure logical correctness. This is critical because it's easy to misinterpret flag logic when documenting conditional branches. For example, when you see code like if ((flags & 0x80) == 0) return early, you must verify whether the flag being set or clear triggers the early return, as documenting this backwards will completely misrepresent the function's behavior. Create a dedicated verification pass where you go through each algorithm step and confirm it matches what the code actually does, not what you think it does. Pay special attention to bitwise operations, conditional logic, and early returns where the semantic meaning can be easily inverted during documentation.

As part of this verification process, create an explicit algorithm-to-code mapping that connects each numbered algorithm step to the specific line or address range in the decompiled code that implements it. This mapping can be included as inline comments at the start of each code section, using annotations like "Algorithm Step 3: Check if buffer exhausted and refill if needed" directly in the decompiler view. This bidirectional mapping ensures that readers can trace from algorithm description to implementation and vice versa, and it forces you as the documenter to verify that every algorithm step has corresponding code and that every significant code block is covered by an algorithm step. If you find code that doesn't map to any algorithm step, either add a step to cover it or determine that it's an edge case that belongs in the Special Cases section rather than the main algorithm flow.

## Inline Comment Documentation

Add comprehensive decompiler comments that provide insight beyond what the code shows using batch_set_comments to efficiently add both decompiler and disassembly comments in a single call. Decompiler comments use PRE_COMMENT type and appear above the code line in the decompiled view, providing context before the reader sees the code. Decompiler comments should explain the algorithm's context and purpose, describe how structures are accessed and what fields mean, document magic numbers and sentinel values, explain validation logic and boundary checks, note edge cases and error handling, include variable re-use notes at semantic change points, and add algorithm step references (for example, "Algorithm Step 3: ..."). For functions with complex control flow involving multiple conditional branches or state transitions, create a state machine documentation section in the plate comment that explicitly enumerates all possible execution states and the transitions between them (for example, when documenting line ending conversion logic that handles different character sequences like CR only, LF only, CR+LF pairs, or buffered characters, create a numbered state machine listing like "State 1: CR followed by LF in buffer → Output single LF, advance by 2" and "State 2: CR at buffer end → Read ahead for LF, buffer CR if no LF follows"). This state machine documentation transforms opaque conditional logic into an understandable decision tree, making it clear which code paths execute under which conditions, and each state should reference the specific algorithm step or code block that implements it.

Disassembly comments use EOL_COMMENT type and appear at the end of the assembly line, making them visible without disrupting the flow of assembly instructions. Do NOT use PRE_COMMENT type for disassembly comments unless absolutely necessary for exceptional clarity, as end-of-line comments are strongly preferred in the disassembly view to maintain visual flow and readability—pre-comments in disassembly create visual clutter and break the natural top-to-bottom reading pattern of assembly code. Disassembly comments should be concise with a maximum of 32 characters that describe the instruction's purpose, such as "Load player slot index", "Check if slot active", or "Jump to error handler." Critically, you must verify offset values against the actual assembly before adding comments, as the assembly shows true memory offsets where an instruction like [EBX + 0x4] means offset +4 from the base, not offset +2. Always match your comment offsets to what appears in the disassembly rather than relying on the decompiler's line order, and document memory access patterns rather than just stating what variable is being loaded.

## Verification and Completeness Checking

After completing major operations like function renaming, prototype setting, or adding comments, always verify that changes applied correctly. Use get_decompiled_code without refresh_cache to view the updated cached decompilation and check that the plate comment appears correctly, validate that comment placement matches the intended addresses, and verify that all decompiler comments are present at their intended code locations explaining what each synthetic variable (dVar12, dVar13, iVar1, uVar3, etc.) represents and how it's used. Do NOT expect variable renaming to have changed the synthetic variable names in the decompiled output, as Ghidra's decompiler generates these names independently based on SSA analysis and they cannot be reliably renamed through the API. Instead, verify that your comprehensive decompiler comments are in place to document what each variable represents (for example, comments like "dVar12: extracted exponent bits for table lookup" and "dVar14: accumulated log2 result"), as these comments provide the documentation value that variable renaming would have provided. All default variable names in the decompiled code (such as dVar12, dVar13, iVar1, uVar3, bVar1, uVar2, in_XMM*, extraout_*, in_stack_*, auVar[N]) are completely expected and normal. These variable names are not failures—they are the decompiler's standard output, and attempting to rename them typically fails silently. Your documentation strategy should focus on inline comments explaining what each variable means, not on trying to change these names.

Before considering the function complete, you MUST perform a final undefined type verification pass by re-examining the disassembly output one last time specifically searching for any remaining undefined types. Use get_disassembly to retrieve the complete assembly listing and systematically scan for undefined type patterns including undefined1, undefined2, undefined4, undefined8 appearing in brackets indicating memory access (for example, [EBP + undefined4]), undefined array types like undefined1[N] used for stack buffers or register spills, and any DAT_ prefixed addresses that indicate untyped global data. For each undefined type found, determine if it was intentionally left undefined because it represents truly unknown data, or if it was accidentally overlooked during the type-setting phase. Common sources of overlooked undefined types include stack variables used only in assembly that don't appear in get_function_variables output, intermediate temporary values stored to stack locations between operations, XMM register spill locations that appear as undefined1[16] in memory references, and global data items accessed through computed addresses rather than direct references. If you find any undefined types that should have been typed, immediately set the correct type using set_local_variable_type for local stack variables or apply_data_type for global data items before marking the function complete. This final verification pass catches undefined types that exist only in the assembly view and ensures complete type coverage across both decompiled and assembly representations of the function.

Use analyze_function_completeness as your final verification step before marking a function complete. This tool performs comprehensive automated checks including verifying the function has a custom name that is not FUN_, has a prototype and calling convention, has a plate comment, globals are renamed with no DAT_ prefixes remaining, and globals have proper types that are not undefined. The tool returns a completeness_score from 0 to 100 with detailed lists of any issues found in the unnamed_globals and undefined_type_globals arrays. When evaluating completeness, understand that some non-renameable variables (register-based implicit parameters and undefined array types) will still appear in the undefined_variables list—this is expected and acceptable if they are properly documented in the plate comment. Do not mark a function as complete unless all renameable local variables have been renamed, all global data items have been named with proper Hungarian notation and have defined types, the function has a descriptive name and prototype, and the plate comment provides clear documentation of parameters including those that could not be renamed.

## Orphaned Function Detection

Before marking a function as complete, you must check for orphaned functions immediately after the current function. Many binaries contain code that appears after unconditional RET instructions without any conditional jumps around them, and these orphaned functions are often referenced only from function pointer tables and are missed by Ghidra's auto-analysis. To detect orphaned functions, examine the disassembly at the function's end to verify it ends with an unconditional RET instruction, then check if executable code exists immediately after the RET by examining the assembly context at the next address. Verify there are no conditional jumps such as JZ, JNZ, or JMP from within the function that target the code after the RET—if there are no such jumps, the code is orphaned. Check if the orphaned address is referenced from data using get_xrefs_to, as references marked as DATA indicate function pointer table entries. If you find orphaned code, use create_function to create a new function at that address, then add the newly created function to your documentation queue. Common signs of orphaned functions include function pointer arrays in the .data section pointing to code addresses, indirect calls through registers loaded from memory with instructions like CALL [register], and switch/case jump tables dispatching to multiple code locations.

## Completeness Criteria and Final Verification

A function is considered fully documented when all of the following criteria are met: it has a descriptive PascalCase name that clearly indicates its purpose; the function prototype includes an accurate return type; all parameters are properly typed (with structure types, not generic pointers) and named; comprehensive decompiler comments document what each variable represents and how it's used, with particular attention to explaining variables that have confusing default names like dVar12, dVar13, iVar1, uVar3, bVar1, uVar2, and explaining non-renameable register-based variables like in_XMM0, in_XMM1_Qa, in_XMM2_Qa, in_XMM3_Qa, in_EAX, in_EDX, extraout_EAX, extraout_XMM0, in_stack_00000008, and undefined arrays like auVar16[16], auVar17[16] with their register storage locations and types; all global data items referenced by the function have meaningful names with correct Hungarian notation prefixes (sz, dw, w, b, h, etc.) based on their actual data type with no remaining DAT_ prefixes or bare address references; all string constants referenced in the disassembly have been renamed with sz prefix (for example, szRegistryKeyName, szFormatString); for pointer arrays, both the array AND all elements it points to have been renamed (for example, g_ModStateKeywords array plus szModeStateClient, szModeStateServer elements); all DWORD globals use dw prefix (for example, g_dwServiceInitialized) NOT b prefix even if used as flags; all handle globals use h prefix (for example, g_hServiceHandle); all structure globals use PascalCase without type prefix (for example, g_ServiceStatus); the plate comment appears in the decompiler showing the function's purpose and structure documentation with algorithm overview; the plate comment includes a comprehensive Parameters section documenting all parameters with their types and purposes, explicitly explaining which variables are non-renameable (in_XMM*, extraout_*, in_stack_*, undefined arrays) and describing their register storage locations, types, and semantic roles in the algorithm; the plate comment includes a comprehensive error handling documentation section that maps all error paths, return codes, and error propagation mechanisms used by the function, showing which Windows API error codes get translated to which errno values, which validation failures result in which error returns, and how errors from called functions are handled or propagated to callers; all jump targets have descriptive snake_case labels; the decompiler shows inline comments at key operations explaining what synthetic variables represent and what operations are being performed; the disassembly has concise comments with a maximum of 32 characters at important instructions; verification shows that all changes were applied successfully with no errors; NO undefined types remain in either the decompiled code OR the disassembly view (all undefined1, undefined2, undefined4, undefined8, undefined1[N] patterns have been replaced with proper lowercase builtin types like byte, ushort, uint, int, float, byte[N], or typed pointers); and orphaned functions have been checked and processed. Only after verifying all these criteria are met and checking for orphaned functions should you consider the function documentation complete.
