# FUNCTION_DOC_PARAGRAPHS

You are assisting with reverse engineering binary code in Ghidra. Your task is to systematically document functions with complete accuracy and comprehensive detail. This workflow follows a logical sequence: establish execution guidelines, initialize and analyze the function, identify structures early, name and type all elements, create comprehensive documentation, and verify completeness. Each section builds on the previous one to ensure you document functions correctly the first time without rework.

## Execution Guidelines and Best Practices

For batch documentation updates, use the currently available MCP tools in the following recommended sequence: begin by renaming the function with rename_function_by_address, then set the function prototype and parameters using set_function_prototype. Proceed to create all necessary labels at once with batch_create_labels, and rename variables in batches using rename_variables, iterating as needed. Add the function header comment with set_plate_comment, and finally apply all decompiler and disassembly comments using batch_set_comments. After each major step, verify that changes were applied successfully. If any batch operation fails due to connection errors or timeouts, retry the operation or switch to smaller batches as needed.

Handle errors appropriately based on their type. For connection timeouts, retry the operation once and then switch to smaller batches if it fails again. For "Variable not found" errors, verify that the variable name is correct and exists in the function. For offset mismatches between your comments and the actual code, cross-reference the disassembly before adding comments to ensure accuracy. During execution, work efficiently and silently without generating excessive status output or progress updates. Do not create or edit any files on the filesystem. Apply all changes directly in Ghidra using the available MCP tools. Use batch operations whenever possible to minimize network round-trips. If batch operations fail with connection errors, retry with individual operations. Allow up to 3 retry attempts for network timeouts before reporting failure.

## Initialization and Boundary Verification

Start by calling get_current_function() to identify the function at the cursor position in Ghidra. For boundary verification, use get_function_by_address to confirm the function's start and end addresses, and examine the disassembly to ensure all code blocks belong to the function and return instructions are properly included at all exit points. If boundaries are incorrect, delete and recreate the function with the correct address range. This initial verification prevents documentation errors caused by incorrect function scope.

## Comprehensive Analysis Phase

Once you have verified the function boundaries, begin the comprehensive analysis phase by using analyze_function_complete on the current function to gather all necessary information in a single efficient call. This tool retrieves the decompiled code, cross-references (both to and from), callees (functions this function calls), callers (functions that call this function), disassembly, and variable information (parameters and locals) simultaneously. Carefully study the decompiled code to understand what the function does, examine how it is called by other functions to understand its context and purpose, review the functions it calls to understand its dependencies, and analyze the disassembly to see actual memory access patterns and offsets. If the decompiler returns an error or null result, the function may not be decompilable—in this case, use the disassembly as the primary source for documentation and note in the plate comment that the function cannot be decompiled.

## Structure Type Identification (CRITICAL - Do This First)

Before proceeding to any documentation or renaming, you must identify all structure types accessed by the function. This is critical because creating structures first ensures field accesses are documented with meaningful names rather than raw offsets, and prevents inconsistencies where different functions document the same structure fields differently. For functions that access structured data through pointer arithmetic and offsets, analyze all offset accesses in the function and search for existing structures using list_data_types to find candidate structures matching the function's domain (for example, search "Unit" for functions with unit pointers like int * pUnit, or search "Item" for item-related functions). Use get_struct_layout to review field layouts and compare field offsets in the disassembly with structure definitions. If a parameter named pUnit accesses offset +0x5c for a pointer and +0x10 for mode flags, search for "UnitAny" and verify it has fields at these offsets. If no matching structure exists, create one using create_struct with fields derived from assembly offsets, and verify the structure size matches the stride or allocation size used in the code. Document the structure layout in a formatted table within the plate comment with columns for Offset, Size, Field Name, Type, and Description, and calculate the total structure size from stride patterns or highest offset. Only after structures are properly defined should you proceed with documenting the function itself.

## Function Naming and Prototype Definition

After completing your analysis and identifying all structures, rename the function using rename_function_by_address with a descriptive PascalCase name based on its purpose and how callers use it. Choose descriptive names that reflect the function's action and target, such as ProcessPlayerSlots for a function that iterates over player data, ValidateEntityState for a function checking entity validity, or InitializeGameResources for a function setting up game structures. Next, set an accurate return data type by examining what value the function returns in EAX: use void if there is no return value, int or uint for status codes or count values, bool for true/false return values, or pointer types for functions returning object references.

Define the complete function prototype using set_function_prototype with all parameters properly typed and named using the identified structure types. Type all pointer parameters with proper structure types (for example, UnitAny * not int *) and give parameters descriptive camelCase names like pPlayerNode, pItem, or nResourceCount. Specify the correct calling convention based on register usage patterns and stack cleanup behavior observed in the assembly. Standard conventions include __cdecl for all parameters on stack with caller cleanup (no RET immediate), __stdcall for all parameters on stack with callee cleanup (RET 0xN), __fastcall for first two parameters in ECX/EDX with remaining on stack and callee cleanup, and __thiscall for implicit this pointer in ECX with remaining parameters on stack and callee cleanup. Diablo II custom conventions include __d2call for first parameter in EBX with remaining on stack and callee cleanup (RET 0xN) which is the most common D2 convention for core game functions, __d2regcall for exactly 3 parameters in EBX/EAX/ECX registers only with caller cleanup (RET) optimized for performance-critical pathfinding, __d2mixcall for first two parameters in EAX/ESI with remaining on stack and callee cleanup (RET 0xN) specialized for list operations, and __d2edicall for context pointer in EDI with remaining on stack and callee cleanup (RET 0xN) used for room/level processing functions. For functions using other implicit register parameters not covered by these conventions, document the actual calling pattern in the function's plate comment under the Parameters section using the IMPLICIT keyword.

After setting the prototype, use get_decompiled_code with refresh_cache=True to update the decompilation with new type information. This refresh is critical because it propagates the new structure types through the decompilation. However, you MUST use refresh_cache=True ONLY after making structural changes that affect type information: creating new structures with create_struct, applying data types to memory with apply_data_type, or modifying function prototypes with set_function_prototype. DO NOT force refresh after cosmetic changes such as variable renames, adding comments, or creating labels, as these changes are automatically reflected in the cached decompilation and forcing refresh can cause decompilation failures on complex functions.

## Label Creation at Control Flow Targets

Proceed to create labels at all jump targets using batch_create_labels to create multiple labels in a single atomic operation. Use snake_case naming conventions: for control flow structures, use descriptive labels like loop_start for the beginning of a loop, loop_continue for continue targets, loop_end for loop exits, or loop_check for condition checks; for validation logic, use labels like validation_failed, check_bounds, or bounds_ok; for error handling, use error_handler, cleanup_and_exit, or handle_failure; and for state machines, use sequential labels like state_0_init, state_1_processing, or state_2_complete.

## Local Variable Renaming

Before attempting to rename variables, you must first call get_function_variables to retrieve the complete variable list and carefully analyze which variables are actually renameable by Ghidra. This is critical because Ghidra has technical limitations on what can be renamed, and attempting to rename non-renameable variables wastes time and creates confusion. The variable types that Ghidra cannot rename are: register-based implicit parameters prefixed with "in_" followed by a register name and type suffix (such as in_XMM0, in_XMM1_Qa, in_XMM2_Qa, in_XMM3_Qa, in_EAX, in_EDX, in_ECX) which represent parameters passed through registers according to the calling convention and cannot be renamed because they are architectural artifacts; register-based implicit return values prefixed with "extraout_" or "output_" (such as extraout_EAX, extraout_XMM0) which represent values returned in registers and cannot be renamed; stack-passed parameters prefixed with "in_stack_" (such as in_stack_00000008, in_stack_0000000c) which represent arguments passed through the stack and maintain fixed storage locations; and undefined array types with square bracket notation (such as auVar16[16], auVar17[16], undefined1 auVar16[16], undefined auVar16[16]) which represent compiler-generated temporary arrays or SSE register spills that Ghidra does not allow renaming. When you encounter these non-renameable variable types in get_function_variables output, skip them during renaming and instead document them in the plate comment.

For the remaining variables that are renameable, systematically rename them using rename_variables to rename multiple variables atomically. The renameable variables include: ordinary local variables with default names like local_8, local_c, local_10, local_14; generic variable names like iVar1, iVar2, iVar3, dVar12, dVar13, dVar14, uVar3, uVar4, uVar5, uVar9, uVar10, lVar20, lVar21, lVar26 that represent computation results; and byte/word/other generic variables like bVar1, uVar2, uVar11, uVar20 that don't match the register-based or array patterns. Replace these generic names with meaningful camelCase names that describe what the variable represents, such as playerIndex for array indices, bufferSize for size values, entityPointer for object pointers, isValid for boolean flags, resultValue for computation outputs, or tempCounter for temporary loop counters. When meaningful, include register-reuse notes in the variable name such as eax_returnValue or ecx_objectPointer to show data flow for variables that represent register reuse.

Create a structured approach: first call get_function_variables to get the complete list, manually categorize each variable as either "renameable" or "non-renameable" based on the patterns above, then batch all renameable renames into a single rename_variables call. This prevents wasted API calls attempting to rename variables that Ghidra will silently skip. For variables that cannot be renamed, document their purpose and usage directly in the plate comment's Parameters section using explicit naming conventions. For example, document "in_XMM1_Qa: Quad precision floating-point parameter passed in XMM1 register" or "extraout_EAX: Implicit return value in EAX register" or "auVar16[16]: Compiler-generated SSE register spill (128-bit temporary)" to make their purpose clear even though their names cannot be changed. Pay special attention to common patterns in renameable variables: iVar1, iVar2, etc. should become descriptive names based on their purpose, and uVar1, lVar1, etc. should be renamed based on their semantic meaning. During variable analysis, watch carefully for variable re-use optimization patterns where compilers repurpose a parameter or local variable after its initial use to save stack space. For example, a parameter named bufferSize might initially hold a size value but later be reused to store a character count or loop index after the size is no longer needed. When you detect variable re-use, document this pattern prominently in a decompiler comment at the point where the variable's semantic meaning changes, using language like "NOTE: bufferSize parameter is reused here as writePosition counter after initial size check completes" to clarify that the same storage location serves multiple purposes at different points in execution. This prevents confusion when reading the decompiled code and explains why a single variable name might seem semantically inconsistent across different code sections.

## Global Data Renaming with Hungarian Notation (CRITICAL)

Identify and rename ALL global data items referenced by the function, not just function-scoped variables. This includes string constants, buffers, configuration values, structure pointers, and function pointer tables. Many global data items will appear with default DAT_ prefixes or as bare numeric addresses in the disassembly—these must be renamed to meaningful names that describe their purpose using proper Hungarian notation type prefixes. When renaming global data items, you MUST apply the correct Hungarian notation prefix based on the actual data type determined by examining the binary, as the prefix must match the physical data size and type in memory, not the semantic meaning of how the data is used.

Start by searching for all global data references within the disassembly. For each global data item found, use list_data_items_by_xrefs to prioritize high-impact globals, then use analyze_data_region to determine its actual data type and size. Apply the correct Hungarian notation prefix based on the physical type. Use cross-reference analysis with get_xrefs_to to trace its usage across all functions. For pointer types, use get_xrefs_from to follow the pointer chain and identify what data the pointer references—you must rename both the pointer variable AND the data it points to, as a common mistake is renaming only the array and forgetting the actual data elements it references. Once you understand what the data represents AND have verified its actual type, use rename_or_label to apply an appropriate name with the correct Hungarian notation prefix (this tool works for both defined data with existing types and undefined addresses).

For null-terminated strings, use the sz prefix to indicate string data. For DWORD types which are 32-bit unsigned integers occupying 4 bytes in memory, use the dw prefix regardless of whether the value represents a flag, counter, or other semantic purpose—a DWORD variable used as an initialization flag must use the dw prefix because it occupies 4 bytes, even though semantically it acts as a boolean. For WORD types which are 16-bit unsigned integers occupying 2 bytes, use the w prefix. For BYTE types which are 8-bit unsigned integers occupying 1 byte, use either b or by prefix, but note that this prefix should only be used for actual single-byte types and never for multi-byte values even if they function as boolean flags. For Win32 handle types such as HANDLE, HKEY, or SERVICE_STATUS_HANDLE, use the h prefix to indicate handle semantics. For raw pointers to untyped or generic data buffers, use the p prefix. For long pointers to string data, use the lpsz prefix. For integer counts or array indices, use the n prefix. For actual boolean flag types, use the f prefix. All global variables must be prefixed with g_ before the type prefix, so a global DWORD becomes g_dw followed by the descriptive name. For structures, use PascalCase naming without any type prefix, as the structure name itself conveys the type information. For arrays, use descriptive plural names that indicate the collection contains multiple elements. For function pointers, use PascalCase with a name that describes the function's purpose or role.

When documenting structure offsets and array strides, establish a consistent documentation pattern that clearly distinguishes between byte offsets, element indices, and calculated addresses. For example, when documenting code like [EBX + EAX*0x24 + 0x4], break down the address calculation explicitly: "EBX (base of file descriptor table) + EAX*0x24 (descriptor index × 36-byte stride) + 0x4 (offset to flags field within descriptor)" rather than simply stating "access flags field." This detailed breakdown helps readers understand multi-level data structures where an index is first scaled by a stride to find a structure, then an offset within that structure locates a specific field. Always document the stride value, explain what it represents (structure size, entry size, etc.), and show how indices are scaled before adding field offsets. When structures are accessed through bucket-based indexing schemes like bucket = index >> 5 and offset = (index & 0x1F) * stride, document both the bucket calculation and the within-bucket offset calculation with explicit bit manipulation explanations.

## Cross-Reference Verification for Flags and Bit Fields

When documenting flag bits or bit field structures, you must cross-reference all usage sites to verify that your bit assignments are consistent with how the flags are actually used throughout the codebase. Use get_xrefs_to on the flag variable to find all functions that access it, then examine how each function masks or tests specific bits using instructions like TEST, AND, OR, or bit shift operations. For example, if you document bit 7 as "Binary mode flag (0x80)" but then find another function testing the same flag with a different semantic meaning like "Append mode," this indicates either an error in your documentation or actual flag reuse that must be noted. Create a Flag Usage Cross-Reference subsection in the plate comment listing each function that accesses the flag and what bit operations it performs, which serves both as validation of your bit assignments and as documentation of where the flags are used throughout the program. Document the purpose and scope of each renamed global in the plate comment if multiple globals are used, or in inline comments near their first reference within the function.

## Comprehensive Plate Comment Creation

Create a comprehensive function header comment using set_plate_comment following the exact format template from docs\prompts\PLATE_COMMENT_FORMAT_GUIDE.md. The plate comment must use plain text format WITHOUT any decorative borders—Ghidra adds all formatting automatically. The format includes: a one-line function summary; an Algorithm section with numbered steps (starting from 1) describing each major operation in the function including all validation checks, function calls, and error handling paths; a Parameters section listing each parameter with its type (with structure types, not generic pointers) and purpose, using the IMPLICIT keyword for undocumented register parameters; a Returns section documenting return values and conditions including success values, error codes, and NULL/zero conditions; a Special Cases section for edge cases and exceptional behavior; a Magic Numbers Reference section listing all numeric constants with their hex value, decimal equivalent, and semantic meaning (this section must be included as standard practice whenever the function uses any numeric constants that aren't immediately obvious from context); an Error Handling section (if applicable) mapping all error paths including Windows API error to errno translations, validation failure to error return mappings, and error propagation from called functions; a State Machine section (if complex control flow exists) enumerating all possible execution states and transitions between them; a Structure Layout section (if function accesses structures) with an ASCII table showing field offsets, sizes, and descriptions; and a Flag Bits section (if applicable) with a detailed bit table using consistent hex notation throughout.

When documenting flag bits, status values, or any numeric constants used for comparison or masking, you must establish and maintain consistent notation standards throughout all sections of the documentation. Use hexadecimal format with 0x prefix for all flag values (for example, 0x02, 0x04, 0x80) rather than mixing decimal and hex notation, as consistency eliminates confusion when cross-referencing between algorithm steps, flag bit tables, and inline comments. When creating flag bit tables, align all hex values consistently and use the same bit numbering scheme (either 0-7 or 1-8) throughout the entire documentation. This notation consistency should extend to magic numbers, error codes, and structure sizes—if you document a flag as 0x80 in the algorithm section, use 0x80 in the flag table and 0x80 in inline comments, never switching to decimal 128 or binary 10000000 in different sections.

Reference specific ordinals, addresses, and magic numbers by their values in the Algorithm section. For structure layouts, use the table format with columns for Offset, Size, Field Name, Type, and Description, and calculate the total structure size from stride patterns or highest offset. Create struct definitions for repeated access patterns using create_struct, and use analyze_data_region to analyze pointer targets and understand data layouts. Replace all undefined types with proper types: undefined1 becomes byte, undefined2 becomes word, undefined4 becomes uint or pointer, and undefined8 becomes qword.

## Algorithm Logic Verification (CRITICAL)

After creating the comprehensive plate comment with numbered algorithm steps, you must immediately verify each step against the actual decompiled code and assembly to ensure logical correctness. This is critical because it's easy to misinterpret flag logic when documenting conditional branches. For example, when you see code like if ((flags & 0x80) == 0) return early, you must verify whether the flag being set or clear triggers the early return, as documenting this backwards will completely misrepresent the function's behavior. Create a dedicated verification pass where you go through each algorithm step and confirm it matches what the code actually does, not what you think it does. Pay special attention to bitwise operations, conditional logic, and early returns where the semantic meaning can be easily inverted during documentation.

As part of this verification process, create an explicit algorithm-to-code mapping that connects each numbered algorithm step to the specific line or address range in the decompiled code that implements it. This mapping can be included as inline comments at the start of each code section, using annotations like "Algorithm Step 3: Check if buffer exhausted and refill if needed" directly in the decompiler view. This bidirectional mapping ensures that readers can trace from algorithm description to implementation and vice versa, and it forces you as the documenter to verify that every algorithm step has corresponding code and that every significant code block is covered by an algorithm step. If you find code that doesn't map to any algorithm step, either add a step to cover it or determine that it's an edge case that belongs in the Special Cases section rather than the main algorithm flow.

## Inline Comment Documentation

Add comprehensive decompiler comments that provide insight beyond what the code shows using batch_set_comments to efficiently add both decompiler and disassembly comments in a single call. Decompiler comments should explain the algorithm's context and purpose, describe how structures are accessed and what fields mean, document magic numbers and sentinel values, explain validation logic and boundary checks, note edge cases and error handling, include variable re-use notes at semantic change points, and add algorithm step references (for example, "Algorithm Step 3: ..."). For functions with complex control flow involving multiple conditional branches or state transitions, create a state machine documentation section in the plate comment that explicitly enumerates all possible execution states and the transitions between them (for example, when documenting line ending conversion logic that handles different character sequences like CR only, LF only, CR+LF pairs, or buffered characters, create a numbered state machine listing like "State 1: CR followed by LF in buffer → Output single LF, advance by 2" and "State 2: CR at buffer end → Read ahead for LF, buffer CR if no LF follows"). This state machine documentation transforms opaque conditional logic into an understandable decision tree, making it clear which code paths execute under which conditions, and each state should reference the specific algorithm step or code block that implements it.

Disassembly comments should be concise with a maximum of 32 characters that describe the instruction's purpose, such as "Load player slot index", "Check if slot active", or "Jump to error handler." Critically, you must verify offset values against the actual assembly before adding comments, as the assembly shows true memory offsets where an instruction like [EBX + 0x4] means offset +4 from the base, not offset +2. Always match your comment offsets to what appears in the disassembly rather than relying on the decompiler's line order, and document memory access patterns rather than just stating what variable is being loaded.

## Verification and Completeness Checking

After completing major operations like function renaming, prototype setting, or adding comments, always verify that changes applied correctly. Use get_decompiled_code without refresh_cache to view the updated cached decompilation and check that the plate comment appears correctly, confirm that all renameable variable renames succeeded and no default names for renameable variables (such as iVar1, iVar2, dVar12, uVar3, bVar1, uVar2, local_8, local_c) remain in the decompiled code, and validate that comment placement matches the intended addresses. It is completely expected and acceptable that non-renameable variables will retain their original names: register-based implicit parameters prefixed with in_XMM*, in_EAX, etc., register-based return values prefixed with extraout_*, stack parameters prefixed with in_stack_*, and undefined array types with square bracket notation like auVar16[16] should all be left as-is and documented in the plate comment instead. After verifying variable renames, examine the plate comment to confirm that all non-renameable variables are properly documented in the Parameters section with their register or storage locations and purposes clearly explained.

Use analyze_function_completeness as your final verification step before marking a function complete. This tool performs comprehensive automated checks including verifying the function has a custom name that is not FUN_, has a prototype and calling convention, has a plate comment, globals are renamed with no DAT_ prefixes remaining, and globals have proper types that are not undefined. The tool returns a completeness_score from 0 to 100 with detailed lists of any issues found in the unnamed_globals and undefined_type_globals arrays. When evaluating completeness, understand that some non-renameable variables (register-based implicit parameters and undefined array types) will still appear in the undefined_variables list—this is expected and acceptable if they are properly documented in the plate comment. Do not mark a function as complete unless all renameable local variables have been renamed, all global data items have been named with proper Hungarian notation and have defined types, the function has a descriptive name and prototype, and the plate comment provides clear documentation of parameters including those that could not be renamed.

## Orphaned Function Detection

Before marking a function as complete, you must check for orphaned functions immediately after the current function. Many binaries contain code that appears after unconditional RET instructions without any conditional jumps around them, and these orphaned functions are often referenced only from function pointer tables and are missed by Ghidra's auto-analysis. To detect orphaned functions, examine the disassembly at the function's end to verify it ends with an unconditional RET instruction, then check if executable code exists immediately after the RET by examining the assembly context at the next address. Verify there are no conditional jumps such as JZ, JNZ, or JMP from within the function that target the code after the RET—if there are no such jumps, the code is orphaned. Check if the orphaned address is referenced from data using get_xrefs_to, as references marked as DATA indicate function pointer table entries. If you find orphaned code, use create_function to create a new function at that address, then add the newly created function to your documentation queue. Common signs of orphaned functions include function pointer arrays in the .data section pointing to code addresses, indirect calls through registers loaded from memory with instructions like CALL [register], and switch/case jump tables dispatching to multiple code locations.

## Completeness Criteria and Final Verification

A function is considered fully documented when all of the following criteria are met: it has a descriptive PascalCase name that clearly indicates its purpose; the function prototype includes an accurate return type; all parameters are properly typed (with structure types, not generic pointers) and named; all renameable variables use descriptive camelCase names with no remaining default generic names like iVar1, iVar2, iVar3, dVar12, dVar13, uVar3, uVar4, uVar5, uVar9, uVar10, bVar1, uVar2, uVar11, uVar20, lVar20, lVar21, lVar26, local_8, local_c, local_10, local_14, param_1, param_2, or similar patterns (note that non-renameable register-based and implicit variables like in_XMM0, in_XMM1_Qa, in_XMM2_Qa, in_XMM3_Qa, in_EAX, in_EDX, extraout_EAX, extraout_XMM0, in_stack_00000008, and undefined arrays like auVar16[16], auVar17[16] are completely acceptable and should not be renamed but rather documented in the plate comment Parameters section instead); all global data items referenced by the function have meaningful names with correct Hungarian notation prefixes (sz, dw, w, b, h, etc.) based on their actual data type with no remaining DAT_ prefixes or bare address references; all string constants referenced in the disassembly have been renamed with sz prefix (for example, szRegistryKeyName, szFormatString); for pointer arrays, both the array AND all elements it points to have been renamed (for example, g_ModStateKeywords array plus szModeStateClient, szModeStateServer elements); all DWORD globals use dw prefix (for example, g_dwServiceInitialized) NOT b prefix even if used as flags; all handle globals use h prefix (for example, g_hServiceHandle); all structure globals use PascalCase without type prefix (for example, g_ServiceStatus); the plate comment appears in the decompiler showing the function's purpose and structure documentation with algorithm overview; the plate comment includes a comprehensive Parameters section documenting all parameters including those that could not be renamed, explicitly explaining which variables are non-renameable (in_XMM*, extraout_*, in_stack_*, undefined arrays) and describing their register storage locations, types, and purposes; the plate comment includes a comprehensive error handling documentation section that maps all error paths, return codes, and error propagation mechanisms used by the function, showing which Windows API error codes get translated to which errno values, which validation failures result in which error returns, and how errors from called functions are handled or propagated to callers; all jump targets have descriptive snake_case labels; the decompiler shows inline comments at key operations explaining what is happening; the disassembly has concise comments with a maximum of 32 characters at important instructions; verification shows that all changes were applied successfully with no errors; and orphaned functions have been checked and processed. Only after verifying all these criteria are met and checking for orphaned functions should you consider the function documentation complete.
